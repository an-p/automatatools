{"version":3,"sources":["ui/visualizations/DFATable.tsx","state/DFAEditor.ts","ui/inputs/DFAInput.tsx","automata/DFA.ts","automata/Automaton.ts","visualizations/MinDFATable.ts","algorithms/MinDFA.ts","ui/visualizations/MinDFATableComponent.tsx","base/Alphabet.ts","ui/visualizations/StateMapComponent.tsx","ui/algorithms/MinDFAComponent.tsx","ui/ToolLinks.tsx","App.tsx","index.tsx"],"names":["DFATable","state","states","dfaStates","initialStateID","readonly","renameState","setInitialState","setFinalState","setEdge","deleteState","alphabet","Array","from","Object","values","reduce","acc","entries","edges","filter","forEach","letter","add","Set","length","rowSpan","colSpan","map","index","id","name","onClick","newName","prompt","type","checked","disabled","onChange","e","currentTarget","final","currentToStateID","value","undefined","toStateID","toState","toStateName","find","alert","initialDFAEditorState","DFAEditorReducer","action","UUID","nextStateNumber","currentStateNumber","Number","parseInt","isNaN","Math","max","toString","addStateAction","deleteStateAction","renameStateAction","toID","Error","fromID","setEdgeAction","setInitialStateAction","setFinalStateAction","convertDFA","dfa","getStates","edge","to","getInitialState","DFAInput","apply","React","useReducer","dispatch","className","keys","window","confirm","DFA","initialState","inputAlphabet","this","has","getInputAlphabet","currentState","minDFATableIndex","id1","id2","setMinDFATableCell","table","state1","state2","word","getMinDFATableCell","MinDFA","stateCount","initialStep","step","stateIDmap","concat","sort","every","combinedStates","stateMap","ids","combinedState","combineStates","push","initial","minDFA","addState","addEdge","changed","i","j","setCurrentState","newState1","read","newState2","join","includes","printWord","done","emptyCellPlaceholder","str","MinDFATableComponent","index1","index2","StateMapComponent","newDFA","newID","MinDFAComponent","useState","setDFA","algorithm","setAlgorithm","setTable","setDone","result","setResult","letterName","stepResult","run","message","ToolLink","url","description","href","rel","target","ToolLinks","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.02b88440.chunk.js","sourcesContent":["import {DFAEditorState} from '../../state/DFAEditor';\nimport React from 'react';\n\nexport type DFATableProps = {\n  state: DFAEditorState;\n  readonly?: boolean;\n  renameState?: (id: string, newName: string) => void;\n  setInitialState?: (id: string) => void;\n  setFinalState?: (id: string, final: boolean) => void;\n  setEdge?: (fromID: string, letter: string, toID?: string) => void;\n  deleteState?: (id: string) => void;\n}\n\nconst DFATable: React.FC<DFATableProps> = (\n  {\n    state: {dfaStates: states, initialStateID},\n    readonly,\n    renameState,\n    setInitialState,\n    setFinalState,\n    setEdge,\n    deleteState,\n  }\n) => {\n  const alphabet = Array.from(Object.values(states).reduce<Set<string>>((acc, state) => {\n    Object.entries(state.edges)\n      .filter(([, toStateID]) => toStateID)\n      .forEach(([letter,]) => acc.add(letter));\n    return acc;\n  }, new Set()));\n\n  return !Object.entries(states).length ? null : (\n    <table>\n      <thead>\n      <tr>\n        <th rowSpan={2}>State</th>\n        <th rowSpan={2}>Initial</th>\n        <th rowSpan={2}>Final</th>\n        <th colSpan={alphabet.length + (readonly ? 0 : 1)}>Transitions</th>\n      </tr>\n      <tr>\n        {alphabet.map(((letter, index) => (<th key={index}>{letter}</th>)))}\n        {!readonly && <th/>}\n      </tr>\n      </thead>\n      <tbody>\n      {Object.entries(states).map(([id, state]) => (\n        <tr key={id}>\n          <td>\n            {readonly ? state.name : <button onClick={() => {\n              const newName = prompt(`Rename state \"${state.name}\" (delete the name to remove the state)`, state.name);\n              if (newName === null) {\n                return;\n              }\n              if (!newName.length) {\n                if (deleteState)\n                  deleteState(id);\n                return;\n              }\n              if (renameState)\n                renameState(id, newName);\n            }}>{state.name}</button>}\n          </td>\n          <td>\n            <input type=\"radio\" checked={id === initialStateID} disabled={readonly} onChange={(e) => {\n              if (e.currentTarget.checked && setInitialState) {\n                setInitialState(id);\n              }\n            }}/>\n          </td>\n          <td>\n            <input type=\"checkbox\" checked={state.final} disabled={readonly} onChange={(e) => {\n              if (setFinalState)\n                setFinalState(id, e.currentTarget.checked);\n            }}/>\n          </td>\n          {alphabet.map((letter, index) => {\n            const currentToStateID = state.edges[letter];\n            return (\n              <td key={index}>\n                {readonly ? (currentToStateID ? states[currentToStateID].name : '-') : <select\n                  value={currentToStateID || '-'}\n                  onChange={(e) => {\n                    if (setEdge)\n                      setEdge(id, letter, e.currentTarget.value === '-' ? undefined : e.currentTarget.value);\n                  }}\n                >\n                  <option value=\"-\">-</option>\n                  {Object.entries(states).map(([toStateID, toState]) => (\n                    <option value={toStateID} key={toStateID}>{toState.name}</option>\n                  ))}\n                </select>}\n              </td>\n            );\n          })}\n          {!readonly && <td>\n            <button onClick={() => {\n              const letter = prompt(`Transition from state \"${state.name}\" with letter`);\n              if (letter === null) {\n                return;\n              }\n              if (letter.length !== 1) {\n                alert(`Invalid letter \"${letter}\" (length must be 1).`);\n                return;\n              }\n              const toStateName = prompt(`Transition from state \"${state.name}\" with letter \"${letter}\" to state`);\n              if (toStateName === null || !toStateName.length) {\n                return;\n              }\n              const toState = Object.entries(states).find(([, toState]) => toState.name === toStateName);\n              if (!toState) {\n                alert(`The state \"${toStateName}\" does not exist.`);\n                return;\n              }\n              if (setEdge)\n                setEdge(id, letter, toState[0]);\n            }}>\n              New\n            </button>\n          </td>}\n        </tr>\n      ))}\n      </tbody>\n    </table>\n  )\n};\n\nexport default DFATable;\n","import * as UUID from 'uuid';\nimport {DFA} from '../automata/DFA';\n\ntype Edges = { [letter: string]: string | undefined };\n\n/**\n * A DFA state for the DFA editor.\n */\nexport type DFAState = {\n  // The name of the state.\n  name: string;\n  // Whether the state is an accepting state.\n  final: boolean;\n  // Edges that originate from this state.\n  edges: Edges;\n};\n\n/**\n * A map of state IDs to DFA states for the DFA editor.\n */\nexport type DFAStates = {\n  [id: string]: DFAState\n}\n\n/**\n * The overall state of the DFA editor.\n */\nexport type DFAEditorState = {\n  // All DFA states.\n  dfaStates: DFAStates;\n  // The ID of the initial DFA state.\n  initialStateID?: string;\n}\n\ntype ResetAction = { type: 'RESET' };\ntype AddStateAction = { type: 'ADD_STATE' };\ntype DeleteStateAction = { type: 'DELETE_STATE', id: string };\ntype RenameStateAction = { type: 'RENAME_STATE', id: string, newName: string };\ntype SetEdgeAction = { type: 'SET_EDGE', fromID: string, toID: string | undefined, letter: string };\ntype SetInitialStateAction = { type: 'SET_INITIAL_STATE', id: string };\ntype SetFinalStateAction = { type: 'SET_FINAL_STATE', id: string, final: boolean };\n\n/**\n * Actions to modify the DFA editor state.\n */\nexport type DFAEditorAction =\n  | ResetAction\n  | AddStateAction\n  | DeleteStateAction\n  | RenameStateAction\n  | SetEdgeAction\n  | SetInitialStateAction\n  | SetFinalStateAction;\n\n/**\n * The initial DFA editor state.\n */\nexport const initialDFAEditorState: DFAEditorState = {\n  dfaStates: {},\n};\n\n/**\n * Resets the DFA editor state.\n */\nfunction resetAction(): DFAEditorState {\n  return initialDFAEditorState;\n}\n\n/**\n * Adds a new DFA state.\n */\nfunction addStateAction(state: DFAEditorState): DFAEditorState {\n  const id = UUID.v4();\n  return {\n    ...state,\n    dfaStates: {\n      ...state.dfaStates,\n      [id]: {\n        name: getNextStateNumber(state.dfaStates).toString(),\n        final: false,\n        edges: {},\n      }\n    },\n    initialStateID: state.initialStateID || id,\n  }\n}\n\n/**\n * Deletes a DFA state.\n */\nfunction deleteStateAction(state: DFAEditorState, action: DeleteStateAction): DFAEditorState {\n  return {\n    ...state,\n    dfaStates: Object.entries(state.dfaStates).reduce((acc, [id, state]) => id === action.id ? acc : {\n      ...acc,\n      [id]: state\n    }, {}),\n    initialStateID: state.initialStateID === action.id ? undefined : state.initialStateID\n  }\n}\n\n/**\n * Renames a DFA state.\n */\nfunction renameStateAction(state: DFAEditorState, action: RenameStateAction): DFAEditorState {\n  return {\n    ...state,\n    dfaStates: {\n      ...state.dfaStates,\n      [action.id]: {\n        ...state.dfaStates[action.id],\n        name: action.newName,\n      }\n    }\n  }\n}\n\n/**\n * Modifies a DFA edge.\n */\nfunction setEdgeAction(state: DFAEditorState, action: SetEdgeAction): DFAEditorState {\n  if (action.toID && !state.dfaStates[action.toID]) {\n    throw new Error('Cannot add edge to non-existent state.');\n  }\n  return {\n    ...state,\n    dfaStates: {\n      ...state.dfaStates,\n      [action.fromID]: {\n        ...state.dfaStates[action.fromID],\n        edges: {\n          ...state.dfaStates[action.fromID].edges,\n          [action.letter]: action.toID,\n        }\n      }\n    }\n  }\n}\n\n/**\n * Sets the initial DFA state.\n */\nfunction setInitialStateAction(state: DFAEditorState, action: SetInitialStateAction): DFAEditorState {\n  if (!state.dfaStates[action.id]) {\n    throw new Error('Cannot set initial state to non-existent state.');\n  }\n  return {\n    ...state,\n    initialStateID: action.id,\n  }\n}\n\n/**\n * Sets whether a DFA state is an accepting state.\n */\nfunction setFinalStateAction(state: DFAEditorState, action: SetFinalStateAction): DFAEditorState {\n  return {\n    ...state,\n    dfaStates: {\n      ...state.dfaStates,\n      [action.id]: {\n        ...state.dfaStates[action.id],\n        final: action.final,\n      }\n    }\n  }\n}\n\nexport function DFAEditorReducer(state: DFAEditorState, action: DFAEditorAction): DFAEditorState {\n  switch (action.type) {\n    case 'RESET':\n      return resetAction();\n    case 'ADD_STATE':\n      return addStateAction(state);\n    case 'DELETE_STATE':\n      return deleteStateAction(state, action);\n    case 'RENAME_STATE':\n      return renameStateAction(state, action);\n    case 'SET_EDGE':\n      return setEdgeAction(state, action);\n    case 'SET_INITIAL_STATE':\n      return setInitialStateAction(state, action);\n    case 'SET_FINAL_STATE':\n      return setFinalStateAction(state, action);\n    default:\n      return state;\n  }\n}\n\nfunction getNextStateNumber(states: DFAStates): number {\n  return Object.values(states).reduce((nextStateNumber, state) => {\n    const currentStateNumber = Number.parseInt(state.name);\n    return Number.isNaN(currentStateNumber) ? nextStateNumber : Math.max(currentStateNumber + 1, nextStateNumber);\n  }, 0)\n}\n\n/**\n * Convers a {@link DFA} to a {@link DFAEditorState}.\n *\n * @param dfa The DFA to convert.\n * @returns The DFA editor state.\n */\nexport function convertDFA(dfa: DFA): DFAEditorState {\n  return ({\n    dfaStates: Object.entries(dfa.getStates()).reduce<DFAStates>((acc, [id, state]) => ({\n      ...acc,\n      [id]: {\n        name: state.name,\n        final: state.final,\n        edges: Object.values(state.edges).reduce<Edges>((acc, edge) => ({\n          ...acc,\n          [edge.letter.name]: edge.to,\n        }), {}),\n      }\n    }), {}),\n    initialStateID: dfa.getInitialState().id,\n  });\n}\n","import React from 'react';\nimport DFATable from '../visualizations/DFATable';\nimport {DFAEditorReducer, DFAEditorState, initialDFAEditorState} from '../../state/DFAEditor';\n\nexport type DFAInputProps = {\n  apply: (state: DFAEditorState) => void;\n}\n\nconst DFAInput: React.FC<DFAInputProps> = ({apply}) => {\n  const [state, dispatch] = React.useReducer(DFAEditorReducer, initialDFAEditorState);\n\n  return (\n    <div className=\"section\">\n      <h2>Edit DFA</h2>\n      <div>\n        <button onClick={() => dispatch({type: 'ADD_STATE'})}>\n          Add State\n        </button>\n        <button\n          disabled={!state.initialStateID || !Object.keys(state.dfaStates).length}\n          onClick={() => apply(state)}\n        >\n          Apply\n        </button>\n        <button onClick={() => {\n          if(window.confirm('Reset DFA?')) {\n            dispatch({type: 'RESET'});\n          }\n        }}>Reset</button>\n      </div>\n      <div>\n        <DFATable\n          state={state}\n          renameState={((id, newName) => dispatch({type: 'RENAME_STATE', id, newName}))}\n          setInitialState={(id) => dispatch({type: 'SET_INITIAL_STATE', id})}\n          setFinalState={(id, final) => dispatch({type: 'SET_FINAL_STATE', id, final})}\n          setEdge={((fromID, letter, toID) => dispatch({type: 'SET_EDGE', fromID, letter, toID}))}\n          deleteState={(id) => dispatch({type: 'DELETE_STATE', id})}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default DFAInput;\n","import * as UUID from 'uuid';\n\nimport {Automaton, Edge, State} from './Automaton';\nimport {Alphabet, Letter} from '../base/Alphabet';\n\n/**\n * A state of a DFA.\n */\nexport interface DFAState extends State<DFAEdge> {\n  // Whether the state is an accepting state.\n  final: boolean;\n}\n\n/**\n * An edge of a DFA.\n */\nexport type DFAEdge = Edge;\n\n/**\n * A representation of a DFA.\n */\nexport class DFA extends Automaton<DFAState, DFAEdge> {\n  /**\n   * Initializes a new DFA.\n   *\n   * @param initialState The initial DFA state.\n   * @param inputAlphabet The initial input alphabet.\n   */\n  constructor(initialState: { id: string, name: string, final: boolean }, inputAlphabet: Alphabet) {\n    super({...initialState, edges: {}}, inputAlphabet);\n  }\n\n  /**\n   * Adds a new state to the DFA.\n   *\n   * @param id The UUID of the new state.\n   * @param name The name of the new state.\n   * @param final Whether the new state is an accepting state.\n   */\n  public addState(id: string, name: string, final?: boolean): void {\n    super._addState({\n      id,\n      name,\n      final: !!final,\n      edges: {},\n    });\n  }\n\n  /**\n   * Adds a new edge to the DFA.\n   *\n   * @param from The ID of the source state.\n   * @param to The ID of the destination state.\n   * @param letter The letter associated with the new edge.\n   */\n  public addEdge(from: string, to: string, letter: Letter): void {\n    if (!this.states[from]) {\n      throw new Error('Invalid from state.');\n    }\n    if (!this.states[to]) {\n      throw new Error('Invalid to state.');\n    }\n    if (!super.getInputAlphabet().has(letter)) {\n      throw new Error('Letter not in input alphabet.');\n    }\n    if (Object.values(this.states[from].edges).find((edge) => edge.letter === letter)) {\n      throw new Error('A DFA state may not have multiple outgoing edges with the same letter.');\n    }\n    super._addEdge({\n      letter,\n      from,\n      to,\n      id: UUID.v4(),\n    });\n  }\n\n  /**\n   * Reads a letter and changes the current state accordingly.\n   *\n   * @param letter The letter to read.\n   * @returns The new current state.\n   */\n  public read(letter: Letter): DFAState {\n    if (!this.getInputAlphabet().has(letter)) {\n      throw new Error('Letter not in input alphabet.');\n    }\n    const edge = Object.values(this.currentState.edges).find((edge) => edge.letter === letter);\n    if (!edge) {\n      throw new Error('Edge not defined. A DFA requires all edges to be defined.');\n    }\n    return this.states[edge.to];\n  }\n\n  /**\n   * Resets the current state to the initial state.\n   */\n  public reset(): void {\n    this.currentState = this.initialState;\n  }\n\n  /**\n   * Sets the current state to the specified state.\n   *\n   * @param state The state that should become the new current state.\n   */\n  public setCurrentState(state: DFAState): void {\n    if (!this.states[state.id]) {\n      throw new Error('The DFA does not have this state.');\n    }\n    this.currentState = state;\n  }\n}","import {Alphabet, Letter} from '../base/Alphabet';\n\n/**\n * A state of an automaton.\n */\nexport interface State<E extends Edge> {\n  // The UUID of the state.\n  id: string;\n  // The name of the state.\n  name: string;\n  // All edges that originate from this state.\n  edges: Edges<E>;\n}\n\n/**\n * An edge of an automaton.\n */\nexport interface Edge {\n  // The UUID of the edge.\n  id: string;\n  // The ID of the source state.\n  from: string;\n  // The ID of the destination state.\n  to: string;\n  // The letter associated with this edge.\n  letter: Letter;\n}\n\n/**\n * Maps state IDs to states.\n */\nexport type States<S> = { [id: string]: S };\n/**\n * Maps edge IDs to edges.\n */\nexport type Edges<E> = { [id: string]: E };\n\n/**\n * An abstract representation of an automaton.\n */\nexport abstract class Automaton<S extends State<E>, E extends Edge> {\n  protected states: States<S>;\n  protected readonly initialState: S;\n  protected currentState: S;\n  private readonly inputAlphabet: Alphabet;\n\n  /**\n   * Initializes a new automaton.\n   *\n   * @param initialState The initial state.\n   * @param inputAlphabet The input alphabet.\n   * @protected\n   */\n  protected constructor(initialState: S, inputAlphabet: Alphabet) {\n    this.states = {[initialState.id]: initialState};\n    this.initialState = initialState;\n    this.currentState = initialState;\n    this.inputAlphabet = inputAlphabet;\n  }\n\n  /**\n   * Adds a state to the automaton. Does not perform any validation.\n   *\n   * @param state The state to add.\n   */\n  protected _addState(state: S): void {\n    this.states[state.id] = state;\n  }\n\n  /**\n   * Adds an edge to the automaton. Does not perform any validation.\n   *\n   * @param edge The edge to add.\n   */\n  protected _addEdge(edge: E): void {\n    this.states[edge.from].edges[edge.id] = edge;\n  }\n\n  /**\n   * Gets all states of the automaton.\n   *\n   * @returns All states.\n   */\n  public getStates(): States<S> {\n    return this.states;\n  }\n\n  /**\n   * Gets the initial state of the automaton.\n   *\n   * @returns The initial state.\n   */\n  public getInitialState(): S {\n    return this.initialState;\n  }\n\n  /**\n   * Gets the input alphabet of the automaton.\n   *\n   * @returns The input alphabet.\n   */\n  public getInputAlphabet(): Alphabet {\n    return this.inputAlphabet;\n  }\n}","import {DFAState} from '../automata/DFA';\nimport {Word} from '../base/Alphabet';\n\n/**\n * The table used by the {@link MinDFA} algorithm to find equivalent states.\n * Maps 2 state IDs to a {@link Word}.\n */\nexport type MinDFATable = { [index: string]: Word };\n\n/**\n * Calculates the index from 2 state IDs.\n *\n * @param id1 The ID of the first state.\n * @param id2 The ID of the second state.\n * @returns The index that can be used to access the value in the table.\n */\nexport function minDFATableIndex(id1: string, id2: string): string {\n  return id1 <= id2 ? `${id1};${id2}` : `${id2};${id1}`;\n}\n\n/**\n * Sets a word in the table.\n *\n * @param table The (immutable) table.\n * @param state1 The first DFA state.\n * @param state2 The second DFA state.\n * @param word The new word.\n * @returns The modified table.\n */\nexport function setMinDFATableCell(table: MinDFATable, state1: DFAState, state2: DFAState, word: Word): MinDFATable {\n  return {...table, [minDFATableIndex(state1.id, state2.id)]: word};\n}\n\n/**\n * Gets a word from the table.\n *\n * @param table The table.\n * @param state1 The first DFA state.\n * @param state2 The second DFA state.\n * @returns The word that is in the table for the 2 specified states or undefined if there is no such word.\n */\nexport function getMinDFATableCell(table: MinDFATable, state1: DFAState, state2: DFAState): Word | undefined {\n  return table[minDFATableIndex(state1.id, state2.id)];\n}\n","import * as UUID from 'uuid';\nimport {Algorithm} from \"./Algorithm\";\nimport {DFA} from '../automata/DFA';\nimport {getMinDFATableCell, MinDFATable, setMinDFATableCell} from '../visualizations/MinDFATable';\n\n/**\n * Maps the state IDs of the DFA to the state IDs of the minimal DFA.\n */\nexport type StateMap = { [oldStateID: string]: string };\n\ntype CombinedState = { id: string, name: string, final: boolean, initial: boolean, ids: string[] };\ntype CombinedStates = { [id: string]: CombinedState };\n\n/**\n * The output of the DFA minimization algorithm.\n */\nexport type MinDFAOutput = {\n  // A minimal DFA that is equivalent to the original DFA or undefined if the original DFA is already minimal.\n  minDFA?: DFA;\n  // Maps the state IDs of the DFA to the state IDs of the minimal DFA or undefined if the original DFA is already minimal.\n  stateMap?: StateMap;\n  // The final minimization table.\n  table: MinDFATable;\n}\n\n/**\n * Minimizes a DFA by combining equivalent states.\n */\nexport class MinDFA implements Algorithm<MinDFAOutput, MinDFATable> {\n  private readonly dfa: DFA;\n  private readonly stateCount: number;\n  private table: MinDFATable;\n  private initialStep: boolean;\n\n  constructor(dfa: DFA) {\n    this.dfa = dfa;\n    this.stateCount = Object.keys(this.dfa.getStates()).length;\n    this.table = {};\n    this.initialStep = true;\n  }\n\n  /**\n   * Runs all remaining algorithm steps, then generates the output.\n   *\n   * @returns The output of the algorithm, see {@link MinDFAOutput}.\n   */\n  run(): MinDFAOutput {\n    while (this.step()) {\n    }\n\n    const stateIDmap = Object.entries(this.dfa.getStates()).reduce<{ [id: string]: string[] }>(\n      (acc, [id1, state1]) => ({\n        ...acc,\n        [id1]: Object.entries(this.dfa.getStates())\n          .filter(([id2]) => id1 !== id2)\n          .reduce<string[]>(\n            (acc, [id2, state2]) => getMinDFATableCell(this.table, state1, state2)\n              ? acc\n              : acc.concat(id2).sort(),\n            [id1]\n          )\n      }),\n      {}\n    );\n\n    if (Object.values(stateIDmap).every((states) => states.length === 1)) {\n      return {table: this.table};\n    }\n\n    const combinedStates: CombinedState[] = [];\n    const stateMap = Object.entries(stateIDmap)\n      .filter(([id, ids]) => ids[0] === id)\n      .reduce<CombinedStates>((acc, [id, ids]) => {\n        const combinedState = this.combineStates(id, this.dfa.getInitialState().id, stateIDmap);\n        combinedStates.push(combinedState);\n        return ids.reduce<CombinedStates>((acc, id) => ({...acc, [id]: combinedState}), acc);\n      }, {});\n    const initialState = combinedStates.find((state) => state.initial)!;\n    const minDFA = new DFA({\n      id: initialState.id,\n      name: initialState.name,\n      final: initialState.final\n    }, this.dfa.getInputAlphabet());\n    combinedStates\n      .filter((state) => state.id !== initialState.id)\n      .forEach((state) => minDFA.addState(state.id, state.name, state.final));\n    combinedStates.forEach(\n      (state) => Object.values(this.dfa.getStates()[state.ids[0]].edges).forEach(\n        (edge) => minDFA.addEdge(state.id, stateMap[edge.to].id, edge.letter)\n      )\n    );\n\n    return ({\n      minDFA,\n      stateMap: Object.entries(stateMap).reduce((acc, [id, state]) => ({...acc, [id]: state.id}), {}),\n      table: this.table,\n    })\n  }\n\n  /**\n   * Compares all states with each other and adds entries to the table if they are not equivalent.\n   *\n   * @returns undefined if the table has not changed since the last step, the new {@link MinDFATable} otherwise.\n   */\n  step(): MinDFATable | undefined {\n    let changed = false;\n\n    for (let i = 1; i < this.stateCount; i++) {\n      const state1 = Object.values(this.dfa.getStates())[i];\n      for (let j = 0; j < i; j++) {\n        const state2 = Object.values(this.dfa.getStates())[j];\n        if (this.initialStep) {\n          if (state1.final !== state2.final) {\n            this.table = setMinDFATableCell(this.table, state1, state2, []);\n            changed = true;\n          }\n        } else if (getMinDFATableCell(this.table, state1, state2) === undefined) {\n          for (const letter of Array.from(this.dfa.getInputAlphabet().values())) {\n            this.dfa.setCurrentState(state1);\n            const newState1 = this.dfa.read(letter);\n            this.dfa.setCurrentState(state2);\n            const newState2 = this.dfa.read(letter);\n            const word = getMinDFATableCell(this.table, newState1, newState2);\n            if (word !== undefined) {\n              this.table = setMinDFATableCell(this.table, state1, state2, [letter].concat(word));\n              changed = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n    this.initialStep = false;\n\n    return changed ? this.table : undefined\n  }\n\n  /**\n   * Combines DFA states to get a state of the minimal DFA.\n   *\n   * @param id The ID of the original state.\n   * @param initialStateID The initial state ID of the original DFA.\n   * @param stateMap A map from the original DFA state IDs to the minimal DFA state IDs.\n   *\n   * @returns A state of the minimal DFA that represents the combination of all states equivalent to the state with the provided ID.\n   * @private\n   */\n  private combineStates(id: string, initialStateID: string, stateMap: { [id: string]: string[] }): CombinedState {\n    return {\n      id: UUID.v4(),\n      name: `{${stateMap[id].map((id) => this.dfa.getStates()[id].name).sort().join(', ')}}`,\n      final: this.dfa.getStates()[id].final,\n      initial: stateMap[id].includes(initialStateID),\n      ids: stateMap[id],\n    }\n  }\n}","import React from 'react';\nimport {States} from '../../automata/Automaton';\nimport {DFAState} from '../../automata/DFA';\nimport {getMinDFATableCell, MinDFATable} from '../../visualizations/MinDFATable';\nimport {wordToString} from '../../base/Alphabet';\n\nexport type MinDFATableComponentProps = {\n  states: States<DFAState>;\n  table: MinDFATable;\n  done: boolean;\n}\n\nfunction printWord(table: MinDFATable, state1: DFAState, state2: DFAState, done: boolean) {\n  const emptyCellPlaceholder = done ? '=' : '';\n  const str = wordToString(getMinDFATableCell(table, state1, state2));\n  return str.length ? str : emptyCellPlaceholder;\n}\n\nconst MinDFATableComponent: React.FC<MinDFATableComponentProps> = ({states, table, done}) => (\n  <div>\n    <table className=\"min-dfa-table\">\n      <thead>\n      <tr>\n        <th/>\n        {Object.values(states).map((state2) => (<th key={state2.id}>{state2.name}</th>))}\n      </tr>\n      </thead>\n      <tbody>\n      {Object.values(states).map((state1, index1) => (\n        <tr key={state1.id}>\n          <th>{state1.name}</th>\n          {Object.values(states).map((state2, index2) => (\n            <td key={state2.id}>\n              {index1 > index2 ? printWord(table, state1, state2, done) : '-'}\n            </td>\n          ))}\n        </tr>\n      ))}\n      </tbody>\n    </table>\n  </div>\n);\n\nexport default MinDFATableComponent;\n","import * as UUID from 'uuid';\n\n/**\n * A set of letters that make up an alphabet.\n */\nexport type Alphabet = Set<Letter>;\n\n/**\n * A letter for use in alphabets.\n */\nexport type Letter = {\n  /**\n   * The UUID of the letter. Must be unique.\n   */\n  id: string;\n  /**\n   * Textual representation of the letter, usually a single character. Should be unique.\n   */\n  name: string;\n}\n\n/**\n * A sequence of letters that makes up a word.\n */\nexport type Word = Letter[];\n\n/**\n * Creates a new letter from a string.\n *\n * @param name Textual representation of the letter.\n * @returns The new letter.\n */\nexport function createLetter(name: string): Letter {\n  return ({name, id: UUID.v4()});\n}\n\n/**\n * Serializes a word. The empty word is serialized as 'ε'. A non-existent (undefined) word is serialized as ''.\n *\n * @param word The word to serialize.\n * @returns The serialized word.\n */\nexport function wordToString(word: Word | undefined): string {\n  if (word === undefined) {\n    return '';\n  }\n  return word.length ? word.reduce((str, letter) => `${str}${letter.name}`, '') : 'ε';\n}","import React from 'react';\nimport {StateMap} from '../../algorithms/MinDFA';\nimport {DFA} from '../../automata/DFA';\n\nexport type StateMapComponentProps = {\n  stateMap: StateMap;\n  dfa: DFA;\n  newDFA: DFA;\n};\n\nconst StateMapComponent: React.FC<StateMapComponentProps> = ({stateMap, dfa, newDFA}) => (\n  <table>\n    <thead>\n    <tr>\n      <th>State</th>\n      <th>New State</th>\n    </tr>\n    </thead>\n    <tbody>\n    {Object.entries(stateMap).map(([id, newID]) => (\n      <tr key={id}>\n        <td>{dfa.getStates()[id].name}</td>\n        <td>{newDFA.getStates()[newID].name}</td>\n      </tr>\n    ))}\n    </tbody>\n  </table>\n);\n\nexport default StateMapComponent;\n","import React from 'react';\nimport DFAInput from '../inputs/DFAInput';\nimport {MinDFA, MinDFAOutput} from '../../algorithms/MinDFA';\nimport {MinDFATable} from '../../visualizations/MinDFATable';\nimport MinDFATableComponent from '../visualizations/MinDFATableComponent';\nimport {createLetter} from '../../base/Alphabet';\nimport {DFA} from '../../automata/DFA';\nimport StateMapComponent from '../visualizations/StateMapComponent';\nimport DFATable from '../visualizations/DFATable';\nimport {convertDFA} from '../../state/DFAEditor';\n\nconst MinDFAComponent: React.FC = () => {\n  const [dfa, setDFA] = React.useState<DFA | undefined>(undefined);\n  const [algorithm, setAlgorithm] = React.useState<MinDFA | undefined>(undefined);\n  const [table, setTable] = React.useState<MinDFATable | undefined>(undefined);\n  const [done, setDone] = React.useState<boolean>(false);\n  const [result, setResult] = React.useState<MinDFAOutput | undefined>(undefined);\n\n  // TODO: ensure all edges are defined\n  return (\n    <div>\n      <DFAInput apply={((state) => {\n        const initialState = state.dfaStates[state.initialStateID!];\n        const inputAlphabet = new Set(Array.from(Object.values(state.dfaStates)\n          .reduce<Set<string>>(((alphabet, state) => {\n            Object.entries(state.edges)\n              .filter(([, toID]) => toID)\n              .forEach(([letter]) => alphabet.add(letter));\n            return alphabet;\n          }), new Set())).map((letter) => createLetter(letter)));\n        const dfa = new DFA(\n          {\n            id: state.initialStateID!,\n            name: initialState.name,\n            final: initialState.final\n          },\n          inputAlphabet\n        );\n        Object.entries(state.dfaStates)\n          .filter(([id]) => id !== state.initialStateID)\n          .forEach(([id, state]) => {\n            dfa.addState(id, state.name, state.final);\n          });\n        Object.entries(state.dfaStates).forEach(([fromID, state]) => {\n          Object.entries(state.edges)\n            .filter(([, toID]) => toID)\n            .forEach(([letterName, toID]) => {\n              dfa.addEdge(fromID, toID!, Array.from(inputAlphabet).find((letter) => letter.name === letterName)!);\n            });\n        });\n        setDone(false);\n        setDFA(dfa);\n        setAlgorithm(new MinDFA(dfa));\n        setTable(undefined);\n        setResult(undefined);\n      })}/>\n      {dfa && <div className=\"section\">\n        <h2>DFA</h2>\n        <DFATable state={convertDFA(dfa)} readonly/>\n      </div>}\n      {dfa && algorithm && <div className=\"section\">\n        <h2>Find equivalent states</h2>\n        <button\n          disabled={done}\n          onClick={() => {\n            try {\n              const stepResult = algorithm.step();\n              if (stepResult !== undefined) {\n                setTable(stepResult);\n              } else {\n                setDone(true);\n                const result = algorithm.run();\n                setTable(result.table);\n                setResult(result);\n              }\n            } catch (e) {\n              alert(`Error: ${e.message}`);\n            }\n          }}\n        >\n          Step\n        </button>\n        {table && <MinDFATableComponent states={dfa.getStates()} table={table} done={done}/>}\n      </div>}\n      {result && !result.minDFA && <div className=\"section\">\n        <h2>Already minimal</h2>\n      </div>}\n      {dfa && result?.stateMap && result?.minDFA && <>\n        <div className=\"section\">\n          <h2>Combine equivalent states</h2>\n          <StateMapComponent stateMap={result.stateMap} dfa={dfa} newDFA={result.minDFA}/>\n        </div>\n        <div className=\"section\">\n          <h2>Minimal DFA</h2>\n          <DFATable state={convertDFA(result.minDFA)} readonly/>\n        </div>\n      </>}\n    </div>\n  )\n};\n\nexport default MinDFAComponent;\n","import React from 'react';\n\ntype ToolLinkProps = {\n  name: string;\n  url: string;\n  description: string;\n}\n\nconst ToolLink: React.FC<ToolLinkProps> = ({name, url, description}) => (\n  <li>\n    <a href={url} rel=\"noreferrer\" target=\"_blank\">{name}</a>: {description}\n  </li>\n);\n\nconst ToolLinks: React.FC = () => (\n  <>\n    <h2>Automata</h2>\n    <ul>\n      <ToolLink\n        name=\"Automaton Simulator\"\n        url=\"https://automatonsimulator.com/\"\n        description=\"Simulate DFAs, NFAs and PDAs\"\n      />\n      <ToolLink\n        name=\"Turing machine visualization\"\n        url=\"https://turingmachine.io/\"\n        description=\"Simulate TMs\"\n      />\n    </ul>\n\n    <h2>Formal grammars</h2>\n    <ul>\n      <ToolLink\n        name=\"CFG Developer\"\n        url=\"https://web.stanford.edu/class/archive/cs/cs103/cs103.1156/tools/cfg/\"\n        description=\"Test context free grammars\"\n      />\n      <ToolLink\n        name=\"CYK Algorithm\"\n        url=\"https://www.xarg.org/tools/cyk-algorithm/\"\n        description=\"Decide the word-problem for context-free grammars (step-by-step)\"\n      />\n      <ToolLink\n        name=\"CFG to CNF\"\n        url=\"https://cyberzhg.github.io/toolbox/cfg2cnf\"\n        description=\"Convert context free grammars to Chomsky normal form\"\n      />\n    </ul>\n\n    <h2>Regular expressions</h2>\n    <ul>\n      <ToolLink\n        name=\"regex101\"\n        url=\"https://regex101.com/\"\n        description=\"Regex tester\"\n      />\n      <ToolLink\n        name=\"Regex Equivalence\"\n        url=\"https://regex-equality.herokuapp.com/\"\n        description=\"Find out if two regular expressions match the same language\"\n      />\n      <ToolLink\n        name=\"Regex => NFA => DFA => Min-DFA\"\n        url=\"https://cyberzhg.github.io/toolbox/min_dfa\"\n        description=\"Convert regex to DFA\"\n      />\n    </ul>\n  </>\n);\n\nexport default ToolLinks;","import React from 'react';\nimport './App.css';\nimport MinDFAComponent from './ui/algorithms/MinDFAComponent';\nimport ToolLinks from './ui/ToolLinks';\n\nfunction App() {\n  return (\n    <div>\n      <h1>Minimize DFA</h1>\n      <MinDFAComponent/>\n      <h1>Other useful tools</h1>\n      <ToolLinks/>\n      <hr/>\n      <a href=\"https://github.com/an-p/automatatools\" rel=\"noreferrer\" target=\"_blank\">GitHub</a>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}